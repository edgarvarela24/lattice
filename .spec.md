# Lattice — Specification v0.5

> **Version:** 0.5.0-draft
> **Status:** Pre-implementation design spec — ready for Phase 1
> **Date:** February 2026

---

## 1. What Lattice Is

Lattice is a **compiled TypeScript UI framework** built on fine-grained signals, compiled tagged templates, and a component model that scales from a counter to an enterprise platform without changing paradigms.

```typescript
Component("Counter", {
  state: { count: 0 },
  template: ({ state }) => html`
    <button @click=${() => state.count++}>
      ${state.count}
    </button>
  `
})
```

One file. One concept. No JSX. No virtual DOM. When `state.count` changes, only the text node inside the button updates — nothing else in the tree runs. The compiler transforms `state.count` into a direct signal-to-DOM subscription at build time. You write property access. The framework does the rest.

### 1.1 Why Lattice Exists

React is simple to start but painful at scale: prop drilling, stale closures, `useEffect` footguns, and a virtual DOM that diffs the entire tree when one value changes.

Angular is powerful at scale but buries you in ceremony on day one: modules, decorators, dependency injection, RxJS. A counter shouldn't require architectural decisions.

Solid.js proved that compiled fine-grained signals are the future of UI performance, but it kept JSX, has no architecture layer, and has DX rough edges (function-call getters, destructuring footguns).

Lattice takes the core insight from Solid (compiled signals → direct DOM updates), fixes the DX (property access, not function calls; mutation works), drops JSX for compiled tagged templates, and adds an architecture layer that no other framework has: opt-in label-based discovery, cross-cutting policies, and a queryable application graph.

**The result:** a framework where `state.count++` reactively updates the DOM, and where adding a tab to your app means creating a file — not modifying a router, a parent component, and a state store.

### 1.2 Core Ideas

**Compiled signals.** All state is fine-grained reactive signals. The compiler analyzes your templates at build time and generates direct signal-to-DOM subscriptions. When a signal changes, only the specific DOM nodes bound to it update. No virtual DOM. No diffing. No re-renders. You write `state.count` — the compiler handles everything else.

**Deep reactivity.** Mutation works. `state.count++`, `state.user.name = "x"`, `state.items.push(newItem)` — all reactive, all tracked, all trigger updates. State objects are deeply proxied. No immutability tax. No spread operator gymnastics.

**Tagged templates, not JSX.** Templates use `html` tagged template literals — standard JavaScript. The compiler parses them at build time and emits optimized DOM operations. No special file extensions. No transpiler ecosystem dependency.

**Grow by addition.** A component starts with `state` and `template`. Need shared state? Add `consumes`. Need discovery? Add `labels`. Need extensibility? Add `children`. Every capability is an opt-in key. Nothing gets rewritten.

**Architecture is data.** The compiler builds the full application graph from every `Component()`, `Service()`, and `Policy()` call. When you opt into labels, that graph becomes queryable and extensible at runtime.

### 1.3 Principles

| Principle | Meaning |
|-----------|---------|
| **One shape** | `Type(name, spec)`. Components, Services, Policies. Learn it once. |
| **Grow by addition** | Adding a capability = adding a key. Never rewriting. |
| **Signals are invisible** | You write `state.count`. The compiler makes it reactive. No `.get()`, no `()`, no `.value`. |
| **Mutation works** | Assignment, increment, array methods, nested property sets — all reactive. |
| **Import code, discover architecture** | Normal imports for utilities. Labels for things that need runtime discovery. |
| **Explicit over magic** | Every connection is traceable. Every match is explainable. |

---

## 2. The Progression

A component grows from simple to fully orchestrated by adding keys to the same object. The template from Step 1 survives unchanged.

### Step 1: Simple Component

Local state. No services. No labels. One file.

```typescript
Component("Counter", {
  state: { count: 0 },
  template: ({ state }) => html`
    <button @click=${() => state.count++}>
      ${state.count}
    </button>
  `
})
```

`state.count` reads the signal and subscribes the DOM node. `state.count++` writes the signal and triggers the update. The compiler makes this work — you never think about subscriptions.

### Step 2: Shared State

Two components need the same state. Extract to a Service. Swap `state` for `consumes`.

```typescript
// services/CounterState.ts
Service("CounterState", {
  kind: "State",
  state: { count: 0 },
  commands: {
    increment: (state) => { state.count++ },
    reset: (state) => { state.count = 0 }
  }
})

// components/Counter.ts — TEMPLATE UNCHANGED from Step 1
import CounterState from '../services/CounterState';

Component("Counter", {
  consumes: { state: CounterState },
  template: ({ state }) => html`
    <button @click=${() => state.count++}>
      ${state.count}
    </button>
  `
})
```

The template is identical to Step 1. `state.count` works the same whether state is inline or consumed from a shared service.

### Step 3: Discoverable

The counter should appear in a dashboard. Add `labels`.

```typescript
Component("Counter", {
  labels: { role: "widget", target: "dashboard" },
  consumes: { state: CounterState },
  template: ({ state }) => html`
    <button @click=${() => state.count++}>
      ${state.count}
    </button>
  `
})
```

One key added. Template unchanged.

### Step 4: Extensible

Other developers can add actions to the counter without modifying it.

```typescript
Component("Counter", {
  labels: { role: "widget", target: "dashboard" },
  consumes: { state: CounterState },
  children: { actions: select({ role: "action", target: "counter" }) },
  template: ({ state, actions }) => html`
    <button @click=${() => state.count++}>
      ${state.count}
    </button>
    <div class="actions">
      <Children from=${actions} context=${state} />
    </div>
  `
})
```

### Step 5: Cross-Cutting Policies

Error handling applied by selector. Counter is never modified.

```typescript
Policy("WidgetErrorBoundary", {
  kind: "Intercept",
  select: { role: "widget" },
  on: {
    renderError: (error, ctx, fallback) =>
      fallback(html`<div class="error">Widget failed to load</div>`)
  }
})
```

**The diff at each step:**

```
Step 1: { state, template }
Step 2: { consumes, template }                            ← swap state → consumes
Step 3: { labels, consumes, template }                    ← add labels
Step 4: { labels, consumes, children, template }          ← add children
Step 5: (separate file — component unchanged)
```

---

## 3. The Compiler

Lattice includes a compiler that transforms templates at build time. The compiler is what makes `state.count` reactive without runtime overhead.

**The compiler is a standalone package** (`@lattice/compiler`) — a pure code transformer with no build tool dependency. It takes TypeScript source in, emits optimized JavaScript out. The Vite plugin (`@lattice/vite`) is the first integration, but the compiler can plug into any build tool or run standalone.

### 3.1 What the Compiler Does

**Input:** TypeScript files with `Component()`, `Service()`, and `Policy()` calls containing `html` tagged templates.

**Output:** Optimized JavaScript with direct DOM operations and signal subscriptions. No runtime template parsing. No virtual DOM.

```typescript
// You write:
template: ({ state }) => html`
  <div class=${state.theme}>
    <span>${state.count}</span>
    <p>${state.name}</p>
  </div>
`

// Compiler generates (conceptually):
function template(ctx) {
  const div = createElement('div');
  const span = createElement('span');
  const p = createElement('p');
  div.append(span, p);

  effect(() => div.className = ctx.state.$.theme());
  effect(() => span.textContent = ctx.state.$.count());
  effect(() => p.textContent = ctx.state.$.name());

  return div;
}
```

Each DOM node subscribes to exactly the signals it reads. When `state.count` changes, only the span's text updates. The div and p are untouched.

### 3.2 What Is Reactive

The compiler only transforms property access on **reactive objects**. Reactive objects are exactly these three things:

1. **`state`** — inline component state
2. **`consumes.*`** — consumed service proxies (each key in `consumes`)
3. **`context`** — data passed from parent components via `<Children context=${...} />`

Everything else is plain JavaScript. A `const x = 5` in an event handler is just a number. A utility function imported from your design system has no reactivity. The compiler does not analyze or transform code outside of these specific objects.

**Invariant: compiled access and proxy access are observationally equivalent.** `state.count` behaves identically inside a template (compiler-optimized path) and inside an event handler (runtime proxy path). Same reads, same writes, same batching, same subscribers. If this invariant is ever violated, it's a framework bug.

### 3.3 Template Purity

**Template expressions must be pure reads.** Mutations live in event handlers, not in template interpolations.

```typescript
// ✅ Pure reads — allowed in template expressions
html`<span>${state.count}</span>`
html`<span>${state.count * 2}</span>`
html`<span>${formatDate(state.createdAt)}</span>`
html`<span>${state.items.length} items</span>`

// ❌ Side effects — compiler errors in template expressions
html`<span>${state.count++}</span>`
html`<span>${state.items.push(x)}</span>`
html`<span>${state.count = 5}</span>`

// ✅ Mutations in event handlers — always allowed
html`<button @click=${() => state.count++}>Click</button>`
html`<button @click=${() => state.items.push(newItem)}>Add</button>`
```

This rule prevents an entire class of "why did this run twice" bugs. The compiler enforces it with clear errors:

```
Error: Side effect in template expression. Mutations must be in event handlers.
  → components/Counter.ts:5  ${state.count++}
```

### 3.4 List Rendering

Standard `.map()` works in templates. The compiler optimizes it when rendering reactive arrays. Use a `key` attribute on the root element for efficient reconciliation:

```typescript
html`
  <ul>
    ${state.items.map(item => html`
      <li key=${item.id}>${item.name}</li>
    `)}
  </ul>
`
```

The `key` attribute is not a real DOM attribute — the compiler strips it and uses it for keyed reconciliation. Additions, removals, and reorders produce minimal DOM mutations.

If you forget the `key` on a reactive array, the compiler warns:

```
Warning: Reactive array mapped without key. Add key=${...} to the root
element for efficient updates. Falling back to index-based reconciliation.
  → components/TodoList.ts:8
```

It still works — just falls back to less efficient index-based reconciliation (like React without keys).

### 3.5 Conditional Rendering

Standard JavaScript conditionals work. The compiler optimizes them:

```typescript
html`
  ${state.isLoading
    ? html`<div class="spinner">Loading...</div>`
    : html`<div class="content">${state.data}</div>`
  }
`
```

The compiler generates code that swaps DOM subtrees when `state.isLoading` changes. The inactive branch is not evaluated.

### 3.6 Component Rendering

The compiler understands three rendering patterns in templates:

```typescript
import { Button } from '../design-system/button';    // normal import (function)
import CounterDisplay from './CounterDisplay';         // Lattice component

html`
  <div>
    ${Button("Click me", { onClick: handler })}

    <CounterDisplay />

    <Children from=${actions} context=${state} />
  </div>
`
```

| Pattern | Meaning |
|---------|---------|
| `${fn()}` | Function call — design system primitives, utility templates |
| `<ComponentName />` | Direct import — compiler generates mount/unmount/lifecycle |
| `<Children from=${ref} />` | Discovery — renders matched child components with context |

`<Children>` is a compiler-recognized element. `from` references a `children` key. `context` passes data to each child component.

### 3.7 Scoped Styles

The `styles` key is extracted and scoped at build time:

```typescript
Component("Counter", {
  state: { count: 0 },
  styles: css`
    button {
      background: var(--color-primary);
      color: white;
      padding: 8px 16px;
      border-radius: 4px;
    }
    button:hover { background: var(--color-primary-dark); }
  `,
  template: ({ state }) => html`
    <button @click=${() => state.count++}>${state.count}</button>
  `
})
```

The compiler:
1. Extracts the CSS at build time (no runtime injection).
2. Scopes selectors with a unique component attribute (e.g. `button[data-l-counter]`).
3. Adds the scoping attribute to the component's root element.
4. Emits static CSS files that the browser caches normally.

**CSS precedence:** Global CSS → Style Policy CSS → Component `styles` (most specific wins). Style Policies are build-time extracted when statically resolvable, runtime injection (cached + deduped) otherwise.

### 3.8 Compile-Time Validation

The compiler catches things TypeScript won't:

```
Error: @clck is not a valid event binding. Did you mean @click?
  → components/Counter.ts:4

Error: Side effect in template expression. Mutations must be in event handlers.
  → components/Counter.ts:5  ${state.count++}

Error: <Children> 'from' must reference a children key. 'actions' is not declared.
  → components/Counter.ts:12

Warning: Reactive array mapped without key.
  → components/TodoList.ts:8

Warning: selector { role: "action", target: "service-row" } matches
0 components.
  → components/ServiceTable.ts:8  children.rowActions

Warning: Expression never changes. Use a plain attribute instead.
  → components/Layout.ts:3  class=${"static-class"}
```

Property typos on typed state objects are caught by TypeScript itself — the compiler doesn't duplicate that work.

### 3.9 Ownership Model (Disposal)

The compiler generates an ownership tree that mirrors the DOM tree. Every template creates an **owner scope**. Every signal subscription belongs to an owner. Disposal is automatic and recursive.

**Rules:**

- Unmount a component → owner scope disposes → all subscriptions disposed.
- Conditional branch swaps → old branch's owner scope disposes.
- List item removed → that item's owner scope disposes.
- HMR swap → old component's owner scope disposes, new one creates fresh.

Memory leaks from undisposed subscriptions are framework bugs, not developer bugs. The developer never manually subscribes or unsubscribes.

### 3.10 Source Maps

The compiler generates full source maps. Errors point to the original TypeScript. Browser dev tools show the original template code. Non-negotiable for trust.

---

## 4. Deep Reactivity

Lattice uses **deep reactive proxies**. Mutation works at any depth.

### 4.1 What Is Tracked

All of the following are reactive and trigger updates:

```typescript
// Top-level property assignment
state.count = 5
state.count++
state.theme = "dark"

// Nested property assignment
state.user.name = "Alice"
state.settings.notifications.email = false

// Array methods
state.items.push(newItem)
state.items.splice(2, 1)
state.items[3] = updatedItem
state.items.sort((a, b) => a.name.localeCompare(b.name))

// Deletion
delete state.user.middleName
```

### 4.2 How It Works

State objects are recursively wrapped in Proxies. Each property access path maps to a signal. Reading a path subscribes the reader. Writing a path notifies all subscribers of that path and any parent paths.

```typescript
state.user.name = "Alice"
// Notifies subscribers of:
//   state.user.name (direct)
//   state.user (parent — because its child changed)
```

### 4.3 Identity Semantics

Proxies maintain stable identity:

```typescript
const user = state.user;     // returns proxy
const same = state.user;     // returns SAME proxy
user === same;               // true
```

The same object is never double-proxied. Non-extensible and frozen objects are not proxied (they can't be reactive — this is a compile-time warning if detected).

### 4.4 Batching

Multiple synchronous mutations batch into one propagation:

```typescript
state.theme = "dark";
state.sidebarOpen = false;
state.activeTab = "logs";
// → ONE propagation, not three
```

### 4.5 Glitch-Free

Topological ordering of the signal graph ensures computed values never see inconsistent intermediate states.

---

## 5. The API: `Type(name, spec)`

Everything in Lattice follows one pattern: a function that takes a name and a spec object.

```typescript
Component(name, spec)    // Produces UI
Service(name, spec)      // Manages reactive state
Policy(name, spec)       // Cross-cutting rules
```

The spec is a plain object. Keys determine capabilities. TypeScript infers the template context from the spec in a single pass.

### 5.1 Spec Composability

Specs are plain objects — they spread, merge, and compose:

```typescript
const withTelescope = { labels: { scope: "telescope" } };

Component("MetricsPanel", {
  ...withTelescope,
  labels: { ...withTelescope.labels, role: "panel", tab: "metrics" },
  consumes: { metrics: MetricsService },
  template: ({ metrics }) => html`...`
})
```

---

## 6. Component

### 6.1 Spec Reference

| Key | Type | Required | Description |
|-----|------|----------|-------------|
| `state` | `object` | No | Inline signal store (deep reactive proxy), local to this component. Accessible as `state` in template context. |
| `labels` | `Record<string, string \| string[]>` | No | Makes the component discoverable by selectors. |
| `consumes` | `Record<string, Service \| ServiceId \| Selector>` | No | Service dependencies. Each key becomes a reactive proxy in template context. |
| `children` | `Record<string, Selector \| Component[]>` | No | Discover child components by selector, or provide them directly as an array. |
| `commands` | `Record<string, Function>` | No | Named actions on inline state. |
| `emits` | `string[]` | No | Declare event names. Makes `emit` available in context. |
| `ready` | `(ctx) => boolean` | No | Readiness check. Defaults to all consumed services ready. |
| `styles` | `css tagged template` | No | Component-scoped CSS. Extracted and scoped at build time. |
| `template` | `(ctx) => TemplateResult` | Yes | Render function. Context typed from all other keys. |

### 6.2 Template Context

The `template` function receives a context object shaped by the spec:

```typescript
Component("Example", {
  state: { count: 0, name: "" },
  consumes: { data: DataService },
  children: { actions: select({ role: "action" }) },
  emits: ["selected"],
  commands: {
    doThing: (state) => { state.count++ }
  },

  // ctx has:
  //   state    → deep reactive proxy of { count, name }
  //   data     → deep reactive proxy of DataService's state
  //   actions  → ComponentRef[] of matched children
  //   emit     → (event, payload?) => void
  //   exec     → (command, ...args) => void
  template: (ctx) => html`...`
})
```

### 6.3 Inline State

When a component has `state`, the runtime creates an anonymous State service. The `state` key in the template context is a deep reactive proxy.

Inline state can have `commands`:

```typescript
Component("TodoList", {
  state: { todos: [] as Todo[], input: "" },
  commands: {
    add: (state) => {
      state.todos.push({ id: Date.now(), text: state.input, done: false });
      state.input = "";
    },
    toggle: (state, id: number) => {
      const todo = state.todos.find(t => t.id === id);
      if (todo) todo.done = !todo.done;
    }
  },
  template: ({ state, exec }) => html`
    <div>
      <input .value=${state.input} @input=${(e) => state.input = e.target.value} />
      <button @click=${() => exec("add")}>Add</button>
      <ul>
        ${state.todos.map(todo => html`
          <li key=${todo.id}
              @click=${() => exec("toggle", todo.id)}
              style=${todo.done ? "text-decoration: line-through" : ""}>
            ${todo.text}
          </li>
        `)}
      </ul>
    </div>
  `
})
```

**Inline state rules:**
- Cannot be discovered, labeled, or consumed by other components.
- Can have commands.
- Policies with `stateChange` hooks can observe it within the component.
- Extracting to a shared service is mechanical: move `state` + `commands` to a `Service()` file, swap `state` for `consumes`.

### 6.4 Component Lifecycle

```
CREATED → WAITING → MOUNTED → ACTIVE ⇄ UPDATING → UNMOUNTED
```

| Phase | Description |
|-------|-------------|
| `CREATED` | Spec registered. Selectors resolved. |
| `WAITING` | Consumed services initializing. Skipped if no `consumes`. |
| `MOUNTED` | Template compiled and rendered to DOM. Owner scope created. Signals subscribed. |
| `ACTIVE` | Live. Signal changes trigger surgical DOM updates. |
| `UPDATING` | A signal changed. Specific DOM nodes update via compiled subscriptions. |
| `UNMOUNTED` | Removed from DOM. Owner scope disposed. All subscriptions cleaned up. |

---

## 7. Service

A Service manages reactive state. Every piece of state is a deep reactive proxy. Components interact with services using the same `state.property` syntax as inline state.

### 7.1 Service Identity and Typing

Services are consumed in three ways:

**Direct import** — consumer knows which service it wants. Types flow from the import.

```typescript
import UserService from '../services/UserService';

Component("Profile", {
  consumes: { user: UserService },
  template: ({ user }) => html`<p>${user.name}</p>`
})
```

**ServiceId** — typed identity for cross-boundary consumption. Resolves by **exact unique ID match** against registered services. A branded string with a generic type parameter.

```typescript
export const USER_DATA = "user-data" as ServiceId<{ name: string; email: string }>;

Service("UserAPI", {
  kind: "Data",
  id: USER_DATA,
  labels: { provides: "user-data" },
  fetch: async () => (await fetch("/api/user")).json()
})

Component("Profile", {
  consumes: { user: USER_DATA },
  template: ({ user }) => html`<p>${user.name}</p>`
})
```

**Selector** — explicit discovery. For when you want "any service matching this query."

```typescript
Component("Dashboard", {
  consumes: { user: select({ provides: "user-data" }, { single: true }) },
  template: ({ user }) => html`<p>${user.name}</p>`
})
```

These three paths are distinct and explicit. ServiceId never secretly acts like a selector. Selectors never secretly match by ID.

### 7.2 Service Kinds

#### State

A writable deep reactive proxy. For UI state, form state, preferences.

```typescript
Service("UIPreferences", {
  kind: "State",
  labels: { provides: "ui-preferences" },
  state: {
    theme: "light" as "light" | "dark",
    sidebarOpen: true,
    activeTab: "metrics"
  }
})
```

Components interact naturally — reads subscribe, writes notify:

```typescript
template: ({ prefs }) => html`
  <button @click=${() => prefs.theme = prefs.theme === "light" ? "dark" : "light"}>
    Theme: ${prefs.theme}
  </button>
`
```

#### Data

A fetch-driven signal store. The framework manages loading, error, and data states.

```typescript
Service("ServiceListAPI", {
  kind: "Data",
  labels: { provides: "service-list" },
  fetch: async () => {
    const res = await fetch("/api/services");
    return res.json();
  },
  sync: { interval: 5000 },
  staleTime: 3000,
  retries: 2,
  commands: {
    delete: async (id: string, { refetch }) => {
      await fetch(`/api/services/${id}`, { method: "DELETE" });
      refetch();
    }
  }
})
```

**Auto-managed state shape:**

```typescript
interface DataState<T> {
  data: T | null;
  status: "idle" | "loading" | "ready" | "error" | "refreshing";
  error: Error | null;
  lastFetched: number | null;
}
```

**Data service options:**

| Key | Type | Default | Description |
|-----|------|---------|-------------|
| `fetch` | `async () => T` | Required | The fetch function. |
| `sync` | `{ interval: ms }` or `{ event: string }` | None | Re-fetch trigger. |
| `staleTime` | `number` | `0` | Data is fresh for this long (ms). |
| `retries` | `number` | `0` | Retry attempts on failure. |
| `retryDelay` | `number` | `1000` | Base delay (doubles each attempt). |

#### Computed

Derives state from other services. Synchronous, no side effects.

```typescript
import ErrorCounts from './ErrorCounts';
import RequestCounts from './RequestCounts';

Service("ErrorRate", {
  kind: "Computed",
  sources: { errors: ErrorCounts, requests: RequestCounts },
  compute: (errors, requests) => ({
    rate: requests.data.total > 0
      ? (errors.data.total / requests.data.total * 100).toFixed(2)
      : "0.00",
    status: errors.data.total / requests.data.total > 0.05 ? "critical" : "healthy"
  })
})
```

#### Stream

Push-driven from WebSocket, SSE, or any push source.

```typescript
Service("LiveLogs", {
  kind: "Stream",
  labels: { provides: "live-logs" },
  connect: (params) => {
    const ws = new WebSocket(`wss://api.example.com/logs`);
    return {
      onMessage: (cb) => { ws.onmessage = (e) => cb(JSON.parse(e.data)); },
      onError: (cb) => { ws.onerror = cb; },
      onClose: (cb) => { ws.onclose = cb; },
      close: () => ws.close()
    };
  },
  buffer: { maxSize: 1000, strategy: "sliding-window" },
  reconnect: { attempts: 5, backoff: "exponential", initialDelay: 1000 }
})
```

**Auto-managed state shape:**

```typescript
interface StreamState<T> {
  items: T[];
  connected: boolean;
  status: "connecting" | "connected" | "disconnected" | "reconnecting" | "error";
  error: Error | null;
  lastMessage: number | null;
}
```

### 7.3 Common Service Keys

| Key | Type | Required | Description |
|-----|------|----------|-------------|
| `kind` | `"State" \| "Data" \| "Computed" \| "Stream"` | Yes | Service behavior. |
| `labels` | `Record<string, string \| string[]>` | No | Makes service discoverable. |
| `id` | `ServiceId<T>` | No | Typed identity for cross-boundary consumption. |
| `commands` | `Record<string, Function>` | No | Named actions. |
| `emits` | `string[]` | No | Declare events. |
| `priority` | `number` | No | Selector tiebreaker. Lower = preferred. |

---

## 8. Policy

A Policy is a cross-cutting rule applied by selector. Policies don't render or hold state.

### 8.1 Style Policy

```typescript
Policy("ErrorInputStyles", {
  kind: "Style",
  select: { role: "input", variant: "error" },
  apply: css`
    border-color: var(--color-error);
    &:focus { outline-color: var(--color-error); }
  `
})
```

Style policies target components by label. Build-time extracted when the match set is statically known; runtime injection (cached + deduped) otherwise.

### 8.2 Intercept Policy

```typescript
Policy("CommandLogger", {
  kind: "Intercept",
  select: { has: "command" },
  on: {
    command: async (name, args, ctx, next) => {
      console.log(`[${ctx.resource}] ${name}`, args);
      return next();
    }
  }
})

Policy("DestructiveGuard", {
  kind: "Intercept",
  select: { destructive: "true" },
  on: {
    command: async (name, args, ctx, next) => {
      if (await confirm(`Confirm ${name}?`)) return next();
    }
  }
})

Policy("PanelErrorBoundary", {
  kind: "Intercept",
  select: { role: "panel" },
  on: {
    renderError: (error, ctx, fallback) =>
      fallback(html`
        <div class="error">
          Failed to load ${ctx.resource}.
          <button @click=${ctx.retry}>Retry</button>
        </div>
      `)
  }
})
```

### 8.3 Intercept Hooks

| Hook | Applies To | Arguments |
|------|-----------|-----------|
| `command` | Services | `(name, args, ctx, next)` |
| `beforeMount` | Components | `(ctx, next)` |
| `afterMount` | Components | `(ctx)` |
| `beforeUnmount` | Components | `(ctx)` |
| `renderError` | Components | `(error, ctx, fallback)` |
| `fetchError` | Data services | `(error, ctx, retry)` |
| `stateChange` | All services | `(key, oldVal, newVal, ctx)` |

---

## 9. Labels & Selectors

Labels and selectors are the **opt-in** composition layer. Components and services without labels work like any other framework — imported directly. Labels make resources discoverable.

### 9.1 Labels

Flat key-value map. Values are strings or arrays of strings.

```typescript
labels: { role: "table", domain: "services", scope: "telescope" }
labels: { role: "action", target: ["service-row", "pod-row"] }
```

### 9.2 Selectors

Partial label map. Matches if all key-value pairs exist in the target's labels.

```typescript
select({ role: "action", target: "service-row" })
select({ has: "command" })
select({ role: "action", not: { destructive: "true" } })
select({ domain: oneOf("metrics", "traces", "logs") })
```

### 9.3 Scope Boundaries

By default, `children` selectors match within the same `scope` label. Explicit override with `{ scope: "global" }`.

### 9.4 Deterministic Ordering

Multiple matches ordered by: explicit `labels.order` → `priority` → registration order.

### 9.5 Ambiguity

`consumes` matching multiple services → error with full explanation. `children` matching multiple components → returns array (expected).

### 9.6 Match Explainability

```bash
lattice explain ServiceTable --child rowActions
lattice explain AdminButton --selector role=action,target=service-row
```

### 9.7 Direct Imports vs Discovery in Children

```typescript
// Direct array — known composition
children: { actions: [DeleteAction, RestartAction] }

// Selector — open extension point
children: { actions: select({ role: "action", target: "service-row" }) }
```

Same key, same template usage.

---

## 10. Import Code, Discover Architecture

Simple, reusable UI building blocks are just functions. Normal imports.

```typescript
// design-system/components.ts — NOT Lattice resources
export const Button = (label: string, opts?: { onClick?: () => void }) =>
  html`<button class="btn" @click=${opts?.onClick}>${label}</button>`;

export const Icon = (name: string) =>
  html`<svg class="icon"><use href="#icon-${name}" /></svg>`;
```

**The litmus test:** "Does something need to find this without knowing it exists?" Yes → labels. No → import.

---

## 11. Signals & Reactivity

All state is deep reactive proxies backed by fine-grained signals. The compiler makes them invisible in templates. Proxies make them invisible in event handlers and commands.

### 11.1 Developer Experience

```typescript
// All of these are reactive
state.count               // read → subscribes
state.count = 5           // write → notifies
state.count++             // write → notifies
state.user.name = "x"    // deep write → notifies
state.items.push(x)      // array mutation → notifies
state.items[3] = y       // indexed write → notifies
```

### 11.2 Batching

Multiple synchronous writes batch into one propagation.

### 11.3 Glitch-Free

Topological ordering prevents inconsistent intermediate states.

---

## 12. TypeScript Strategy

### 12.1 Single-Pass Inference

`Component(name, spec)` lets TypeScript infer the template context from the spec in one pass. No chained generics.

### 12.2 Direct Import Typing

Types flow from imports — no extra mechanism needed for most apps.

### 12.3 ServiceId Typing

For discovery-based consumption, `ServiceId<T>` carries the type as a generic on a branded string.

---

## 13. Incremental Adoption

### 13.1 Mount API

```typescript
import { mount } from 'lattice';
const island = mount('#container', { components: [...], services: [...], policies: [...] });
island.dispose();
```

### 13.2 Inside React / Angular

Mount in a ref/ViewChild. Dispose on unmount.

### 13.3 Web Component Export

```typescript
import { exportAsWebComponent } from 'lattice';
exportAsWebComponent('my-widget', { components: [...], services: [...] });
```

---

## 14. Build & Tooling

### 14.1 Vite Plugin

```typescript
import { defineConfig } from 'vite';
import lattice from '@lattice/vite';

export default defineConfig({
  plugins: [
    lattice({ include: ['src/**'], devtools: true, strict: true })
  ]
});
```

### 14.2 Dev Tools

Browser extension: registry inspector, dependency graph, signal inspector, match explainer, performance timeline.

### 14.3 CLI

```bash
npx lattice create my-app
lattice validate
lattice query --selector role=tab
lattice explain ServiceTable --child rowActions
lattice graph
lattice preview src/components/NewTab.ts
```

---

## 15. AI Agent Integration

**Adding features = creating files.** One file with the right labels. Zero existing files touched.

**Architecture is queryable.** The compiler builds the full app graph from every `Component()`, `Service()`, `Policy()` call. Agents query it via `lattice describe`, `lattice query`, and the registry API.

**Validation without execution.** `lattice validate` checks everything statically.

**Predictable spec shape.** `Type(name, spec)` — agents generate it structurally.

**Multi-agent safety.** No cross-imports for discovered resources. No merge conflicts.

---

## 16. Comparison

| Concern | React | Angular | Solid | **Lattice** |
|---------|-------|---------|-------|-------------|
| **Counter** | `useState` + JSX | Decorator + template | `createSignal` + JSX | **`state.count++` + html** |
| **Reactivity** | Virtual DOM diffing | Zone.js / signals | Compiled signals | **Compiled signals** |
| **Reactivity depth** | Immutable only | Shallow | Immutable only | **Deep proxy — mutation works** |
| **Templates** | JSX (compiler) | Custom syntax (compiler) | JSX (compiler) | **Tagged templates (compiler)** |
| **Signal DX** | `count` (stale closure risk) | `signal()` | `count()` fn call | **`state.count` property access** |
| **State scaling** | useState → Redux | Services + RxJS | Signals → stores | **Inline state → Service (same API)** |
| **Adding a feature** | Modify parent + router + store | Modify module + router | Modify parent + router + store | **Add a file (with labels)** |
| **Cross-cutting** | HOCs / middleware | Interceptors | N/A | **Policies by selector** |
| **AI agent compat** | Low | Low | Low | **High** |

---

## 17. Repository Structure

Monorepo with independently publishable packages:

```
lattice/
├── packages/
│   ├── core/              # Registry, labels, selectors, dependency graph
│   │   └── package.json   # @lattice/core
│   ├── signals/           # Signal primitives, deep reactive proxy, batching, ownership
│   │   └── package.json   # @lattice/signals
│   ├── compiler/          # Template transformer — standalone, no build tool dependency
│   │   └── package.json   # @lattice/compiler
│   ├── runtime/           # Component mounting, service lifecycle, policy engine
│   │   └── package.json   # @lattice/runtime
│   ├── vite/              # Vite plugin (wraps compiler)
│   │   └── package.json   # @lattice/vite
│   ├── devtools/          # Browser extension
│   │   └── package.json   # @lattice/devtools
│   └── lattice/           # Main package — re-exports everything
│       └── package.json   # lattice (what users npm install)
├── apps/
│   ├── docs/              # Documentation site
│   └── telescope/         # Reference app
├── tests/
│   ├── compiler/          # Compiler snapshot tests
│   ├── signals/           # Signal + proxy behavior tests
│   └── integration/       # Full component lifecycle tests
├── pnpm-workspace.yaml
├── turbo.json
└── package.json
```

**Dependency graph:**

```
@lattice/signals     → (no dependencies)
@lattice/core        → @lattice/signals
@lattice/compiler    → @lattice/core, @lattice/signals (compile-time analysis only)
@lattice/runtime     → @lattice/core, @lattice/signals
@lattice/vite        → @lattice/compiler
@lattice/devtools    → @lattice/core, @lattice/signals
lattice              → @lattice/runtime, @lattice/vite (re-exports)
```

---

## 18. Implementation Phases

Each phase must be complete, tested, and hardened before moving to the next. "Done" means the test suite is comprehensive and passing, edge cases are handled, and manual verification confirms correctness.

---

### Phase 1: Signal Engine (`@lattice/signals`)

**What:** The foundation. Fine-grained signal primitives, computed signals, effects, batching, glitch-free propagation, and the ownership/disposal model.

**Build:**
- `signal<T>(value): Signal<T>` — writable reactive value
- `computed<T>(fn): Computed<T>` — derived signal, auto-tracks dependencies
- `effect(fn): Disposable` — side effect, re-runs when dependencies change
- `batch(fn)` — groups multiple writes into one propagation
- `Owner` — scope that tracks child effects/computeds for disposal
- `createOwner()`, `runWithOwner(owner, fn)`, `owner.dispose()`

**Tests (exhaustive):**
- Signal read/write
- Computed auto-tracking (reads inside `computed` are tracked)
- Computed does not re-run when unrelated signals change
- Effect runs on dependency change
- Effect does not run when unrelated signals change
- Diamond dependency: A depends on B and C, both depend on D. Changing D runs A once with consistent values (glitch-free)
- Batch: multiple writes → one propagation
- Nested batch: inner batch doesn't flush until outer completes
- Owner disposal: creating effects inside an owner, disposing the owner, verifying effects no longer run
- Nested owners: parent dispose cascades to children
- Conditional dependencies: effect reads signal A, then conditionally reads B. When condition changes, B dependency is added/removed correctly
- Computed identity: same value produced → dependents don't re-run (equality check)
- Circular dependency detection: A depends on B, B depends on A → clear error
- GC: disposed effects are garbage collected (no leaked references)
- Performance: 10,000 signals, 1,000 computeds, bulk update — measure propagation time

**Done when:**
- All tests pass
- No memory leaks under repeated create/dispose cycles (test with WeakRef)
- Propagation is deterministic and glitch-free for all dependency graph shapes
- `batch()` and ownership model work under nested/async scenarios
- Can be used standalone as `@lattice/signals` with no other dependencies

---

### Phase 2: Deep Reactive Proxy (`@lattice/signals`)

**What:** The proxy layer that makes `state.count++` and `state.items.push(x)` reactive. Wraps objects/arrays in recursive Proxies backed by the Phase 1 signal primitives.

**Build:**
- `reactive<T>(obj): T` — returns a deep reactive proxy
- Proxy get trap: returns proxied nested objects, subscribes reader to the accessed path
- Proxy set trap: notifies subscribers of the changed path and parent paths
- Array method interception: `push`, `pop`, `splice`, `shift`, `unshift`, `sort`, `reverse`, `fill`, `copyWithin` all trigger updates
- `delete` trap: handles property deletion
- Identity map: same source object always returns same proxy (WeakMap cache)
- Non-extensible/frozen object detection: skip proxying, warn at compile time

**Tests (exhaustive):**
- Top-level property read/write reactivity
- Nested property read/write reactivity (2, 3, 4 levels deep)
- Array `.push()`, `.pop()`, `.splice()`, `.shift()`, `.unshift()` trigger updates
- Array `.sort()`, `.reverse()` trigger updates
- Array index assignment `arr[3] = x` triggers updates
- Array `.length` read is reactive
- `delete` triggers updates
- Nested object replacement: `state.user = newUser` — old nested proxy is invalidated, new one works
- Identity stability: `state.user === state.user` is always true
- No double-proxying: proxy of a proxy returns the same proxy
- Non-extensible objects: not proxied, access works but isn't reactive (with warning)
- Frozen objects: same as above
- `Map` and `Set` behavior (decide: proxy or skip with warning)
- Prototype chain: proxy doesn't break `instanceof`, `constructor`, etc.
- `JSON.stringify(state)` works (returns raw data, not proxy metadata)
- Computed reacts to deep changes: `computed(() => state.user.name)` updates when `state.user.name = "x"`
- Effect reacts to deep changes
- Batching works with deep mutations: multiple nested writes → one propagation
- Performance: 1,000-item array, bulk operations, measure overhead vs plain objects

**Done when:**
- All mutation patterns listed in Section 4.1 are reactive and tested
- Identity semantics are stable and tested
- No memory leaks from proxy chain (WeakMap cleanup)
- Performance overhead is <2x plain object for common operations
- Works seamlessly with Phase 1 signal primitives
- Can be used standalone: `const state = reactive({ count: 0 }); effect(() => console.log(state.count));`

---

### Phase 3: Core Registry (`@lattice/core`)

**What:** The application graph. Stores all Component, Service, and Policy specs. Label indexing. Selector matching. Scope boundaries. Dependency graph construction.

**Build:**
- `Registry` class: `register(type, name, spec)`, `query(selector)`, `describe(name)`, `graph()`
- Inverted label index: O(1) selector matching
- Scope boundary enforcement
- Dependency graph builder (DAG from `consumes` and `children`)
- Topological sort for service initialization order
- Ambiguity detection and error messages with match explanations
- `validate()` — check unresolved selectors, cycles, ambiguity

**Tests (exhaustive):**
- Register component/service/policy
- Query by selector: exact match, partial match, no match
- Array label matching: selector value matches any element
- `has`, `not`, `oneOf` special selectors
- Scope: same scope matches, different scope doesn't, global override works
- Ambiguity: `consumes` matching 2+ services → error with explanation
- Children: matching multiple components → returns array (not error)
- Dependency graph: A consumes B, B consumes C → correct topological order
- Circular dependency: A → B → A → detected, clear error
- Priority: lower priority wins tiebreaker
- Deterministic ordering: explicit order label → priority → registration order
- `describe()` returns full spec + resolved dependencies
- `graph()` returns complete DAG with all edges
- `validate()` catches: unresolved selectors, cycles, ambiguity, scope violations
- Performance: 500 components, 200 services, 50 policies — registration + query timing

**Done when:**
- All selector patterns work correctly
- Ambiguity produces clear, actionable error messages
- Dependency graph construction handles all edge cases
- `validate()` catches every known error class
- Pure Node.js — no DOM, no browser, no build tool dependency

---

### Phase 4: Compiler Pass-Through (`@lattice/compiler`)

**What:** The compiler shell. Parses TypeScript files, identifies `Component()`, `Service()`, `Policy()` calls, extracts `html` tagged templates, and initially passes them through to a lightweight runtime renderer. Source maps work.

**Build:**
- TypeScript/JavaScript parser (use an existing parser: `@swc/core`, `oxc-parser`, or `typescript` compiler API)
- `Component()` / `Service()` / `Policy()` call detection
- `html` tagged template extraction and AST representation
- Template-to-runtime-calls pass-through (emit code that uses a small runtime to create/patch DOM from tagged templates — similar to lit-html but minimal)
- Lightweight runtime renderer: `createTemplate(strings, values)` → DOM nodes with manual patching
- Source map generation
- Vite plugin wrapper (`@lattice/vite`) that calls the compiler during `transform` hook

**Tests (exhaustive):**
- Parse component file → extract name, spec keys, template
- Parse service file → extract name, kind, spec keys
- Parse policy file → extract name, kind, spec keys
- Template extraction: simple interpolation, nested templates, event handlers
- Pass-through rendering: compiled output produces identical DOM to the source template
- Source maps: error in generated code maps back to correct line in source
- Multi-component file: multiple `Component()` calls in one file all extracted
- Non-component code in same file: preserved untouched
- Edge cases: template with no interpolations, template with only interpolations, deeply nested html`` templates
- Vite integration: dev server starts, HMR works (file change triggers re-compile)

**Done when:**
- A simple component (`Counter` with inline state) renders in the browser
- Template output matches expected DOM structure
- Source maps are accurate (verified in browser devtools)
- Vite dev server runs with hot module replacement
- This is the "it works" milestone — correctness, not performance

---

### Phase 5: Compiler Signal Unwrapping (`@lattice/compiler`)

**What:** The core DX win. The compiler detects property access on reactive objects inside templates and generates direct signal-to-DOM subscriptions using Phase 1/2 primitives.

**Build:**
- Identify reactive objects in template context (`state`, each key of `consumes`)
- For each template expression, analyze property access chains on reactive objects
- Generate `effect(() => node.textContent = ctx.state.$.count())` style code
- Handle attribute bindings: `class=${state.theme}` → `effect(() => el.className = ...)`
- Handle boolean attributes: `?disabled=${state.loading}` → `effect(() => el.disabled = ...)`
- Handle event handlers: `@click=${() => state.count++}` → leave as runtime proxy (don't compile)
- Handle property bindings: `.value=${state.input}` → `effect(() => el.value = ...)`
- Handle conditional expressions: ternary in interpolation → reactive branch swap
- Handle nested expressions: `${state.items.length} items` → signal subscription on items

**Tests (exhaustive):**
- Text interpolation: `${state.count}` → signal subscription, updates on change
- Attribute binding: `class=${state.theme}` → signal subscription, attribute updates on change
- Boolean attribute: `?disabled=${state.loading}` → toggles correctly
- Event handler: `@click=${() => state.count++}` → handler works, mutation triggers text update
- Property binding: `.value=${state.input}` → two-way binding works
- Multiple expressions: template with 5 different reactive expressions, each independently reactive
- Unchanged signals: only the specific DOM nodes for changed signals update (verify with spy/counter)
- Non-reactive expressions: `${"static string"}` → no effect wrapper, no subscription
- Pure function calls: `${formatDate(state.createdAt)}` → effect wraps the expression, re-runs when createdAt changes
- Mixed: `${state.count * 2 + 1}` → effect on expression, re-runs when count changes
- Deep property access in template: `${state.user.name}` → signal subscription on deep path
- Optional chaining: `${state.user?.name}` → handles null/undefined
- Conditional: ternary with reactive condition → correct branch swap
- Nested templates: reactive expression inside a map callback inside a conditional
- Verify template purity: `${state.count++}` → compiler error
- Verify template purity: `${state.items.push(x)}` → compiler error
- Performance: 100 reactive expressions in one template → measure update time for single signal change (should be O(1), not O(n))

**Done when:**
- `state.count` in a template is reactive without any runtime overhead beyond the effect
- Only affected DOM nodes update (verified by counting DOM operations)
- Template purity violations produce clear compiler errors
- The Counter example works with `state.count++` in an event handler updating `${state.count}` in the text
- Performance is measurably better than the Phase 4 pass-through approach

---

### Phase 6: Runtime Engine (`@lattice/runtime`)

**What:** Component mounting, service lifecycle, policy application, the full runtime loop.

**Build:**
- `mount(target, config)` — boots a Lattice island
- Component lifecycle: CREATED → WAITING → MOUNTED → ACTIVE → UNMOUNTED
- Service lifecycle: initialization in topological order
- State service: creates deep reactive proxy from `state` spec key
- Data service: manages fetch/loading/error/data states as signals
- Computed service: derives from source services, re-evaluates on change
- Stream service: connection management, buffering, reconnection
- `consumes` resolution: direct import → use directly; ServiceId → match by ID; selector → match by labels
- `children` resolution: direct array → use directly; selector → match by labels
- `<Children>` rendering: mount matched components with context
- `<ComponentName />` rendering: mount imported component
- Policy application: style injection, intercept hook registration
- Readiness gating: component waits for consumed services
- `island.dispose()` — clean teardown of everything

**Tests (exhaustive):**
- Mount a simple component (inline state, no services) → renders to DOM
- Mount a component consuming a State service → state is shared, reactive
- Mount a component consuming a Data service → loading state → data appears
- Data service: sync interval triggers re-fetch
- Data service: retries on failure
- Computed service: updates when source changes
- Stream service: receives messages, buffers, reconnects
- Children discovery: parent discovers children by selector, renders them
- Children direct: parent renders directly provided component array
- Policy style: component with matching labels gets style applied
- Policy intercept: command intercepted, next() works, blocking works
- Policy error boundary: component throws → fallback rendered → retry works
- Readiness: component doesn't render until services are ready
- Service topological initialization: C depends on B depends on A → A inits first
- Multiple islands: two `mount()` calls on same page, independent
- Dispose: `island.dispose()` removes all DOM, disposes all signals, cleans up
- HMR: swap component file → DOM updates without full page reload
- HMR: swap service file → consumers re-render with new data

**Done when:**
- The Telescope example app runs end-to-end
- All service kinds work with real async data
- Policies apply correctly
- Discovery and direct import paths both work
- Clean dispose with zero memory leaks
- HMR works in Vite dev server

---

### Phase 7: Compiler Optimization (`@lattice/compiler`)

**What:** The performance tier. Static template analysis, createElement-based DOM construction, keyed list reconciliation, conditional branch optimization, CSS extraction.

**Build:**
- Static analysis: identify static vs dynamic parts of templates
- DOM construction: generate `createElement` / `createTextNode` calls instead of innerHTML
- Keyed list reconciliation: detect `.map()` with `key`, generate efficient diff/patch
- Unkeyed list fallback: detect `.map()` without `key`, emit warning, use index-based reconciliation
- Conditional optimization: ternary in templates → branch swap without evaluating inactive branch
- CSS extraction: parse `css` tagged templates, scope selectors, emit static CSS files, add scoping attributes
- Dead expression elimination: detect expressions that never change, emit as static content

**Tests (exhaustive):**
- Static content: `html`<h1>Hello</h1>`` → no effects, no subscriptions, pure DOM creation
- Mixed static/dynamic: static parts are created once, dynamic parts have effects
- Keyed list: add/remove/reorder items → minimal DOM mutations (count operations)
- Keyed list: 1000 items, remove one from middle → only 1 DOM removal (not 999 recreations)
- Unkeyed list: works but emits compiler warning
- Conditional branches: inactive branch is never created/evaluated
- Conditional swap: switching branches disposes old branch's owner scope
- CSS scoping: selectors are correctly scoped to component
- CSS extraction: output CSS file contains scoped selectors, no runtime injection
- CSS precedence: global < policy < component styles
- Performance benchmark: compare Phase 5 output vs Phase 7 output on a complex template. Target: 50%+ reduction in initial render time, 80%+ reduction in update time.

**Done when:**
- Compiled output produces measurably less DOM operations than pass-through
- Keyed list reconciliation handles add/remove/reorder correctly
- CSS is extracted and scoped at build time
- Performance is competitive with Solid.js on common benchmarks (js-framework-benchmark)

---

### Phase 8: Dev Tools & CLI

**What:** Developer experience tooling.

**Build:**
- CLI: `lattice create`, `lattice validate`, `lattice query`, `lattice explain`, `lattice graph`, `lattice preview`
- Browser extension: registry inspector, dependency graph visualization, signal inspector (live values + history), match explainer, performance timeline

**Done when:**
- `lattice validate` catches all known error classes
- `lattice explain` produces clear match/no-match explanations
- Browser extension shows live signal values and graph
- Useful enough that a developer encountering "why doesn't my component show up" can diagnose it in under 60 seconds

---

### Phase 9: Documentation & Reference App

**What:** The public face.

**Build:**
- Documentation site with guides, API reference, examples
- Telescope reference app (the full example from Appendix A)
- Migration guides (from React, Angular, Solid)
- "First 5 minutes" tutorial that goes from install to Counter to shared state

**Done when:**
- A developer with React experience can build a working app from the docs without asking for help
- The Telescope app demonstrates every feature in the spec

---

## Appendix A: Full Example — Telescope Application

### Services

```typescript
Service("ApplicationAPI", {
  kind: "Data",
  labels: { provides: "application-data", scope: "telescope" },
  fetch: async () => (await fetch("/api/applications/telescope")).json(),
  sync: { interval: 30000 }
})

Service("MicroserviceGraph", {
  kind: "Data",
  labels: { provides: "microservice-graph", scope: "telescope" },
  fetch: async () => (await fetch("/api/applications/telescope/topology")).json(),
  sync: { interval: 10000 }
})

Service("TraceData", {
  kind: "Data",
  labels: { provides: "trace-data", scope: "telescope" },
  fetch: async () => (await fetch("/api/applications/telescope/traces")).json(),
  sync: { interval: 5000 }
})

Service("TelescopeUI", {
  kind: "State",
  labels: { provides: "telescope-ui-state", scope: "telescope" },
  state: { activeTab: "microservices", activeSubTab: "explorer", timeRange: "2h" }
})
```

### Components

```typescript
import ApplicationAPI from '../services/ApplicationAPI';
import TelescopeUI from '../services/UIState';
import { StatCard, TimeRangeSelector } from '../design-system/components';

Component("AppLayout", {
  labels: { role: "layout", type: "root", scope: "telescope" },
  consumes: { app: ApplicationAPI, ui: TelescopeUI },
  children: { tabs: select({ role: "tab" }, { sort: "labels.order" }) },
  styles: css`
    .app-details { padding: 24px; }
    .summary-bar { display: flex; gap: 16px; margin: 16px 0; }
    .tab-bar { display: flex; gap: 4px; border-bottom: 1px solid var(--border); }
    .tab-bar button.active { border-bottom: 3px solid var(--primary); font-weight: 600; }
  `,
  template: ({ app, ui, tabs }) => html`
    <div class="app-details">
      <header>
        <h1>Application details</h1>
        ${TimeRangeSelector({ value: ui.timeRange, onChange: (v) => ui.timeRange = v })}
      </header>
      <div class="summary-bar">
        ${StatCard("Microservices", app.data?.serviceCount)}
        ${StatCard("Traces", app.data?.traceCount)}
        ${StatCard("APIs", app.data?.apiCount)}
        ${StatCard("Errors", app.data?.errorCount)}
      </div>
      <nav class="tab-bar">
        ${tabs.map(tab => html`
          <button key=${tab.labels.tabId}
                  class=${ui.activeTab === tab.labels.tabId ? "active" : ""}
                  @click=${() => ui.activeTab = tab.labels.tabId}>
            ${tab.labels.title}
          </button>
        `)}
      </nav>
      <main>
        ${tabs.filter(t => t.labels.tabId === ui.activeTab).map(T => html`<${T} />`)}
      </main>
    </div>
  `
})

Component("MicroservicesTab", {
  labels: { role: "tab", tabId: "microservices", title: "Microservices", order: "1", scope: "telescope" },
  children: { panels: select({ role: "panel", tab: "microservices" }) },
  template: ({ panels }) => html`
    <div class="split-view">
      <div class="left">
        ${panels.filter(p => p.labels.position === "left").map(P => html`<${P} key=${P.name} />`)}
      </div>
      <div class="right">
        ${panels.filter(p => p.labels.position === "right").map(P => html`<${P} key=${P.name} />`)}
      </div>
    </div>
  `
})

import MicroserviceGraph from '../services/MicroserviceGraph';
import { formatNumber } from '../design-system/formatters';

Component("ServiceListPanel", {
  labels: { role: "panel", tab: "microservices", position: "left", scope: "telescope" },
  consumes: { graph: MicroserviceGraph },
  template: ({ graph }) => html`
    <table>
      <thead><tr><th>Service</th><th>Errors</th><th>Requests</th></tr></thead>
      <tbody>
        ${graph.data?.services.map(svc => html`
          <tr key=${svc.name}>
            <td>${svc.name}</td>
            <td>${svc.errors != null ? formatNumber(svc.errors) : "No data"}</td>
            <td>${svc.requests != null ? formatNumber(svc.requests) : "No data"}</td>
          </tr>
        `)}
      </tbody>
    </table>
  `
})

Component("TopologyGraph", {
  labels: { role: "panel", tab: "microservices", position: "right", scope: "telescope" },
  consumes: { graph: MicroserviceGraph },
  template: ({ graph }) => html`
    <div class="topology">
      <canvas id="topology-canvas"></canvas>
    </div>
  `
})

// Adding a new tab — ONE FILE
Component("LogsTab", {
  labels: { role: "tab", tabId: "logs", title: "Logs", order: "3", scope: "telescope" },
  template: () => html`<div>Logs content here</div>`
})
```

### Policies

```typescript
Policy("PanelErrorBoundary", {
  kind: "Intercept",
  select: { role: "panel" },
  on: {
    renderError: (error, ctx, fallback) =>
      fallback(html`
        <div class="error">
          Failed to load ${ctx.resource}.
          <button @click=${ctx.retry}>Retry</button>
        </div>
      `)
  }
})
```

---

*End of spec v0.5. Ready for implementation.*